## 9.3.3 数据模型设计的基本原则

### 1.高内聚和低耦合

​		从数据业务特性和访问特性来考虑：将业务相近或者相关、粒度相同的数据设计为一个逻辑或者物理模型；

​		将高概率同时访问的数据放在一起，将低概率同时访问的数据分开存储。

### 2.核心模型与扩展模型分离

​		核心模型包括的字段支持常用的核心业务，扩展模型包括的字段支持个性化或少量应用的需要。

​		不能让扩展模型的字段过度侵入核心模型，以免破坏核心模型的架构简洁性与可扩展性。

### 3.公共处理逻辑下沉及单一

​		越是底层公用的处理逻辑越应该在数据调度依赖的底层进行封装与实现，不要让公用的处理逻辑暴露给应用层实现，不要让公用逻辑多处同时存在。

### 4.成本与性能平衡

​		适当的数据冗余可换取查询和刷新性能，但不宜过度冗余与数据复制。

### 5.**数据可回滚**

​		处理逻辑不变，在不同时间多次运行数据，结果确定不变。

### 6.一致性

​		具有相同含义的字段在不同表中的命名必须相同，必须使用规范定义中的名称。

### 7.命名清晰、可理解

​		表命名需清晰、一致，表名需易于消费者理解和应用。





# 第十章  维度设计

## 10.1 维度设计基础

### 1. 维度是维度建模的基础和灵魂

​	 	在维度建模中，将度量成为“事实”，将环境描述为“维度”，维度是用于分析事实所需要的多种环境。

​	 	例如，在分析交易过程中时，可以通过买家、卖家、商品和时间等维度描述交易发生的环境。维度的作用一般是查询约束、分类汇总以及排序等。













## 10.2 维度变化

### 1.缓慢变化维

​		数据仓库的重要特点之一是反映历史变化，所以如何处理维度的变化是维度设计的重要工作之一。

​		在实际的业务场景中，维度的属性并不是静态的，它会随着时间的流逝发生缓慢的变化。与数据增长较为快速的事实表相比，维度变化相对缓慢。

### 2.处理方式

（1）重写维度值

​			该方式不保留历史数据，始终保存最新的数据。                                   

（2）插入新的维度行

​			该方式保留历史数据，维度值变化前的事实与过去的维度值关联，维度值变化后的事实与当前的维度值关联。

（3）添加维度列

### 3.快照维表

​		数仓的计算周期一般是每天一次，基于此周期，处理维度变化的方式是每天保留一份全量快照数据。

​		例如商品维度， 每天保留一份全量商品快照数据。任意一天的事实均可以获取到当天的商品信息，也可以获取到最新的商品信息，通过限定日期，采用自然键进行关联即可。

> 优点：
>
> （1）简单而有效，开发和维护成本低。
>
> （2）使用方便，易于理解。

> 弊端：
>
> ​		对于存储资源的极大浪费。通过牺牲存储来获取ETL效率的优化和逻辑的简化。
>
> ​		如果存储成本远低于CPU、内存等的成本，则使用快照维表的方式是利大于弊的。

### 4.历史拉链表

​		通过新增两个时间字段：开链时间(start_date)和关链时间(end_date)，将所有以天为粒度的变更数据都记录下来。

> 优点：节约了存储空间。

> 缺点：
>
> （1）对于维表下游的使用方存在着一定的理解障碍，解释成本较高。
>
> （2）若使用start_date和end_date做分区，随着时间的推移，分区数量会极度膨胀，而现行的数据库系统都有分区数量限制。

上述两个问题的解决方案：

（1）透明化

​		底层的数据还是历史拉链存储，但是上层做一个视图操作或者在Hive里做一个hook，通过分析语句的语法树，实现：

```sql
select * from A where date = "2021-06-06"
```

等价于：

```sql
select * 
	from A
	where start_date <= "2021-06-06" and end_date >= '2021-06-06'
```

（2）分月做历史拉链表

## 5.拉链表的创建方式

存储每日关注用户的全量日志表为log(A)，以此为基础创建拉链表mart_wechat.user (B)

(1)用A初始化拉链表B

(2)用每日的增量数据更新拉链表：

更新今日取关用户

union all

今日新增关注用户

## 6.拉链表的重导

### 1.上游log表重导

​		设$now.date = '2021-06-06' ， 上游log表自‘2021-05-25’开始数据更改。

```sql
insert overwrite table mart_wechat.dim_user_info
select 
	unionid,
	userid,
	start_date,
	case when end_date >= '2021-05-24' then '9999-12-31' else end_date end as end_date
	from mart_wechat.dim_user_info 
	where start_date <= '2021-05-25'
```

先将拉链表的数据回滚至‘2021-05-24’ ，即日志表未出错的状态，之后再用新的日志表更新拉链表。

### 2.下游事实表重导

​		用 start_date <= stat_date and end_date >= stat_date取统计日的用户全量快照。